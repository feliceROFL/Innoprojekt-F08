/*
 * IP24-Skript.ino
 *
 * Dieses Programm steuert einen linienfolgenden Roboter mit Hilfe eines PI-Reglers. 
 * Der Roboter verwendet QTR-Sensoren (Infrarot Sensor) zur Linienverfolgung und steuert zwei Gleichstrommotoren 
 * über ein Adafruit-Motor-Shield. Der PI-Regler berechnet die notwendigen Anpassungen 
 * der Motorgeschwindigkeit, um den Roboter auf der Linie zu halten. 
 * Es gibt verschiedene Linienstatus (onLine, stop, station, goal), die je nach 
 * Sensorwerten aktualisiert werden und spezifische Aktionen auslösen.
 * 
 * Enthaltene Funktionen:
 * 
 * 1. **setup():**
 *    - Diese Funktion wird einmalig beim Starten des Programms aufgerufen.
 *    - Initialisiert die wichtigsten Module und Systeme des Roboters:
 *      - **initMotorShield():** Initialisiert das Motorschield zur Steuerung der Motoren.
 *      - **initDriveLine():** Initialisiert das System zur Linienverfolgung des Roboters.
 *      - **sensorKalibrieren():** Führt eine Kalibrierung der Sensoren durch, um eine zuverlässige Linienerkennung zu gewährleisten.
 *    - Dieser Abschnitt bietet auch Platz für benutzerdefinierte Setup-Funktionen, die vom Benutzer hinzugefügt werden können.
 * 
 * 2. **loop():**
 *    - Diese Funktion wird kontinuierlich in einer Endlosschleife ausgeführt und bildet das Herzstück des Roboterbetriebs.
 *    - Der Roboter führt folgende Hauptaufgaben aus:
 *      - **Linienverfolgung:** Liest die aktuelle Position der Linie anhand der Sensoren.
 *      - **PI-Regelung:** Aktualisiert den PI-Regler mit der aktuellen Linienposition und berechnet das Steuersignal.
 *      - **Motorkontrolle:** Passt die Motorgeschwindigkeiten basierend auf dem berechneten Steuersignal an.
 *      - **Linienstatus-Überwachung:** Überwacht kontinuierlich den Status der Linie und reagiert auf Veränderungen:
 *        - **stop:** Hält den Roboter an.
 *        - **station:** Führt eine benutzerdefinierte Aktion bei Erreichen einer Station aus.
 *        - **goal:** Schaltet eine LED ein, wenn das Ziel erreicht ist.
 *        - **default:** Schaltet die LED aus, wenn kein besonderes Ereignis vorliegt.
 *    - Ein Zähler überwacht, wie lange der Roboter im Zielzustand bleibt und stoppt die Motoren nach einer definierten Zeit.
 *    - Der `delay(25)`-Aufruf sorgt für eine kleine Verzögerung, um die Stabilität des Regelkreises zu gewährleisten.
 * 
 * Verwendung:
 * - Dieses Skript sollte auf den Mikrocontroller hochgeladen werden, um den Roboter zu steuern.
 * - Die `setup()`-Funktion dient der Initialisierung, während die `loop()`-Funktion kontinuierlich die Roboterfunktionen ausführt.
 * 
 * Hinweise:
 * - Die Kalibrierung der Sensoren ist entscheidend für eine zuverlässige Linienverfolgung.
 * - Der PI-Regler sollte optimal abgestimmt sein, um eine präzise Steuerung der Motoren zu gewährleisten.
 * - Benutzerdefinierte Aktionen können in den vorgesehenen Abschnitten des Skripts eingefügt werden.
 */

#include "03_defines.h" // Das File 03_Defines.h muss in jedem .ino File eingebunden werden.

// Die Setup-Funktion wird einmalig beim Start des Programms aufgerufen. 
// Hier werden alle notwendigen Initialisierungen des Roboters durchgeführt.
void setup()
{
  initMotorShield();   // Initialisiert das Motorschield zur Steuerung der Motoren.
  initDriveLine();     // Initialisiert die Linienverfolgungssensoren des Roboters.
  sensorKalibrieren(); // Kalibriert die Sensoren durch mehrfache Messungen, um die Genauigkeit zu verbessern.
  
  /****************************
  * Benutzerdefinierte Setup-Funktionen können hier hinzugefügt werden.
  ****************************/
}

// Die Loop-Funktion wird kontinuierlich ausgeführt, solange der Roboter eingeschaltet ist. 
// Sobald das Programm das Ende der Funktion erreicht, beginnt es wieder von vorne.

int counter = 1;

void loop() {
  
  int position = qtr.readLineBlack(sensorValues);
  double controlSignal = updatePI(&pi, position);

  setMotorSpeeds(controlSignal);
  updateLineStatus();
  
  
  if (lineStatus != lineOldStatus) {
    switch (lineStatus) {
  case stop:
    // Stop-Reaktion
    motorR->setSpeed(0);
    motorL->setSpeed(0);
    delay(1000);

    switch (counter) {
      case 4: {
        // === 360°-Drehung über Linien-Überquerungen (QTR) ===
        // Drehe auf der Stelle nach links

        motorL->run(FORWARD);
        motorL->setSpeed(40);
        motorR->run(FORWARD);     // linkes Rad rückwärts
        motorR->setSpeed(40);    // rechtes Rad vorwärts
        delay(300);

        motorL->run(FORWARD);
        motorL->setSpeed(40);
        motorR->run(BACKWARD);     // linkes Rad rückwärts
        motorR->setSpeed(40);    // rechtes Rad vorwärts
        
        int crossings   = 0;
        bool onLineNow  = false;
        bool onLinePrev = false;

        while (crossings < 3) {
          // Sensoren lesen & Status aktualisieren
          updateLineStatus();
          int position = qtr.readLineBlack(sensorValues);

          // *** Schwelle an Kalibrierung anpassen! ***
          // position ca. 0..7000 (je nach Setup); hier Beispiel:
          onLineNow = (position > 1000 && position < 5000);

          // Flanke: von "kein Linie" -> "Linie"
          if (onLineNow && !onLinePrev) {
            crossings++;
          }

          onLinePrev = onLineNow;
          delay(10);
        }

        // Nach 360°-Drehung anhalten
        motorL->setSpeed(0);
        motorR->setSpeed(0);
        delay(500);
        break;
      }

      case 2: {
        motorD->run(FORWARD);
        motorD->setSpeed(50);
        delay(500);
        motorD->setSpeed(0);
        break;
      }

      case 3: {
         // === 360°-Drehung über Linien-Überquerungen (QTR) ===
        // Drehe auf der Stelle nach links

        motorR->run(FORWARD);
        motorR->setSpeed(40);
        motorL->run(FORWARD);     // linkes Rad rückwärts
        motorL->setSpeed(40);    // rechtes Rad vorwärts
        delay(300);

        motorR->run(FORWARD);
        motorR->setSpeed(40);
        motorL->run(BACKWARD);     // linkes Rad rückwärts
        motorL->setSpeed(40);    // rechtes Rad vorwärts
        
        int crossings   = 0;
        bool onLineNow  = false;
        bool onLinePrev = false;

        while (crossings < 3) {
          // Sensoren lesen & Status aktualisieren
          updateLineStatus();
          int position = qtr.readLineBlack(sensorValues);

          // *** Schwelle an Kalibrierung anpassen! ***
          // position ca. 0..7000 (je nach Setup); hier Beispiel:
          onLineNow = (position > 1000 && position < 5000);

          // Flanke: von "kein Linie" -> "Linie"
          if (onLineNow && !onLinePrev) {
            crossings++;
          }

          onLinePrev = onLineNow;
          delay(10);
        }
      }

      case 1: {
        servo1.attach(SERVOPIN1);
        servo1.write(90);
        servo1.writeMicroseconds(10);
        break;
      }

      case 5: {
        motorR->setSpeed(0);
        motorL->setSpeed(0);
        delay(5000000000);
        break;
      }

      default:
        updateLineStatus();
        if (lineStatus == stop) {
          motorR->run(FORWARD);
          motorR->setSpeed(40);
          motorL->run(FORWARD);     // linkes Rad rückwärts
          motorL->setSpeed(40);
          delay(1000);
        }
        break;
    }

    // Nur bei STOP weiterzählen
    if (counter < 6) counter++;
    break;

  case station:
    motorR->setSpeed(0);
    motorL->setSpeed(0);
    delay(3000);
    break;

  case goal:
    digitalWrite(LED_BUILTIN, HIGH);
    break;

  default:
    digitalWrite(LED_BUILTIN, LOW);
    break;
}
  }

  
  delay(25);
}
